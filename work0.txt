/*
 * GccApplication1.c
 *
 * Created: 10/15/2018 11:49:12 AM
 * Author : bryant
 */ 

#include "sam.h"

#define D00 PORT_PB26
#define D01 PORT_PB27
#define D02 PORT_PB28
#define D03 PORT_PB29


void clockSetup(void);
void portSetup(void);
void wait(volatile int d);
void sercom_0_Setup(void);
void writeUart(char *a);

volatile char menuArray[7][63] = {	//DO NOT FUCK WITH THIS 
									{"\n\n_________________________________________________________  \n\n"},
									{"                Artium Technologies, Inc Gen 3.0 Rev 0.0      \n"},
									{"_________________________________________________________    \n\n"},
									{"M=> Show Menu                                                 \n"},
									{"DxXXX D=Analog Out x=Cannel Number 0 to 15 XXX=000 to 255     \n"},
									{"KxXX K=Port K x-Bit 0 to 15 X= State H or L                   \n"},
									{"T=> Show Current Temperature Status\n\n#                        "},
									};//DO NOT FUCK WITH THIS 
volatile char *menuPtr;
volatile int receiveCount = 0;	//receive array counter
volatile char receiveArray[10] = {"0000000000"};
volatile char receiveKey;
volatile char *arrayPtr;
volatile int state = 0;

	
int main(void){

    SystemInit();	//Initialize the SAM system
	clockSetup();
	portSetup();
	sercom_0_Setup();
	
	Port *por = PORT;
	PortGroup *porB = &(por->Group[1]);
	arrayPtr = receiveArray;
	menuPtr = menuArray;
	while(1){	
	
		if(receiveKey == 13){	//look for carriage return
		
			if(((*arrayPtr+0 == 'm') || (*arrayPtr+0 == 'M')) && (receiveCount = 1)){	//verifying valid menu selection
				writeUart(menuPtr);
				receiveCount = 0;
				receiveKey = 0;
			}
			else if(((*arrayPtr+0 == 'd') || (*arrayPtr+0 == 'D')) && (receiveCount = 4)){	//verifying valid input for digital
				writeUart("\n\ndigi\n");
				receiveCount = 0;
				receiveKey = 0;
			
				if((*(arrayPtr+1) >= 48) && (*(arrayPtr+1) <= 57)){	//looking for number keys only
					if((*(arrayPtr+2) >= 48) && (*(arrayPtr+2) <= 57)){	//looking for number keys only
					volatile int zone = (*(arrayPtr+1) - 48) * 10;
					zone += *(arrayPtr+2) - 48;
			
						switch(zone){
							case 0:
							if(*(arrayPtr+3) == 'L' || *(arrayPtr+3) == 'l'){
							porB->OUTCLR.reg = D00;
							}
							else if(*(arrayPtr+3) == 'H' || *(arrayPtr+3) == 'h'){
							porB->OUTSET.reg = D00;
							}
							break;
					
							case 1:
							if(*(arrayPtr+3) == 'L' || *(arrayPtr+3) == 'l'){
							porB->OUTCLR.reg = D01;
							}
							else if(*(arrayPtr+3) == 'H' || *(arrayPtr+3) == 'h'){
							porB->OUTSET.reg = D01;
							}
							break;
					
							case 2:
							if(*(arrayPtr+3) == 'L' || *(arrayPtr+3) == 'l'){
							porB->OUTCLR.reg = D02;
							}
							else if(*(arrayPtr+3) == 'H' || *(arrayPtr+3) == 'h'){
							porB->OUTSET.reg = D02;
							}
							break;
					
							case 3:
							if(*(arrayPtr+3) == 'L' || *(arrayPtr+3) == 'l'){
							porB->OUTCLR.reg = D03;
							}
							else if(*(arrayPtr+3) == 'H' || *(arrayPtr+3) == 'h'){
							porB->OUTSET.reg = D03;
							}
							break;
					
							case 4:
							break;
							case 5:
							break;
							case 6:
							break;
							case 7:
							break;
							case 8:
							break;
							case 9:
							break;
							case 10:
							break;
							case 11:
							break;
							case 12:
							break;
							case 13:
							break;
							case 14:
							break;
							case 15:
							break;
					
							default:
							break;
						}
					}
				}
			}
		
			//else if((receiveChar == 'a') || (receiveChar == 'A')){	//analog stuff
			//writeUart("\n\nana\n");
			//}
		
			else{	//invalid key press, reset array 
				receiveCount = 0;
				receiveKey = 0;
			}
		}
	}
}

void clockSetup(void){
	//12MHz crystal on board selected mapped to PB22/PB23
	OSCCTRL->XOSCCTRL[1].bit.ENALC = 1;	//enables auto loop ctrl to control amp of osc
	OSCCTRL->XOSCCTRL[1].bit.IMULT = 4;
	OSCCTRL->XOSCCTRL[1].bit.IPTAT = 3;
	OSCCTRL->XOSCCTRL[1].bit.ONDEMAND = 1;
	OSCCTRL->XOSCCTRL[1].bit.RUNSTDBY = 1;
	OSCCTRL->XOSCCTRL[1].bit.XTALEN = 1;	//select ext crystal osc mode
	OSCCTRL->XOSCCTRL[1].bit.ENABLE = 1;
	
	GCLK->GENCTRL[0].reg = GCLK_GENCTRL_SRC_XOSC1 | GCLK_GENCTRL_RUNSTDBY | !(GCLK_GENCTRL_DIVSEL) | GCLK_GENCTRL_OE | GCLK_GENCTRL_GENEN | 12<<16;	//divide by 12 1MHz
	while(GCLK->SYNCBUSY.bit.GENCTRL0){}	//wait for sync
	
	//channel 7, SERCOM0
	GCLK->PCHCTRL[7].bit.CHEN = 0;	//disable for safety first
	GCLK->PCHCTRL[7].reg = GCLK_PCHCTRL_CHEN | GCLK_PCHCTRL_GEN_GCLK0;
	
	MCLK->CPUDIV.reg = 1;	//divide by 1
	MCLK->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;	//do not mask sercom0
	
}

void portSetup(void){
	Port *por = PORT;
	PortGroup *porA = &(por->Group[0]);
	PortGroup *porB = &(por->Group[1]);
	PortGroup *porC = &(por->Group[2]);
	PortGroup *porD = &(por->Group[3]);
	
	///for SERCOM0
	porA->PMUX[2].bit.PMUXE = 3;
	porA->PINCFG[4].bit.PMUXEN = 1;
	porA->PMUX[2].bit.PMUXO = 3;
	porA->PINCFG[5].bit.PMUXEN = 1;

	porB->DIRSET.reg = D00 | D01 | D02 | D03;	//digital outputs
}

void sercom_0_Setup(void){
	Sercom *ser = SERCOM0;
	SercomUsart *uart = &(ser->USART);
	uart->CTRLA.reg = 0;	//enable protected regs
	while(uart->SYNCBUSY.reg){}
	uart->CTRLA.bit.DORD = 1;	//LSB transferred first
	uart->CTRLA.bit.CMODE = 0;	//asynchronous mode
	uart->CTRLA.bit.SAMPR = 0;	//16x oversampling using arithmetic
	uart->CTRLA.bit.RXPO = 1;	//RX is pad1 PA05
	uart->CTRLA.bit.TXPO = 2;	//TX is pad0 PA04
	uart->CTRLA.bit.MODE = 1;	//uart with internal clock
	uart->CTRLB.bit.RXEN = 1;	//enable RX
	uart->CTRLB.bit.TXEN = 1;	//enable TX
	uart->CTRLB.bit.PMODE = 0;	//even parity mode
	uart->CTRLB.bit.SBMODE = 0;	//1 stop bit
	uart->CTRLB.bit.CHSIZE = 0;	//8bit char size
	while(uart->SYNCBUSY.reg){}
	uart->BAUD.reg = 55470;	//for fbaud 9600 at 1Mhz fref
	uart->INTENSET.bit.RXC = 1;	//receive complete interr
	NVIC->ISER[1] |= 1<<16;	//enable sercom0 int
	uart->CTRLA.reg |= 1<<1;	//enable
	while(uart->SYNCBUSY.reg){}
	//NVIC->ISER[1] = NVIC_EnableIRQ
}

void SERCOM0_2_Handler(void){	//for recieving 
	Sercom *ser = SERCOM0;
	SercomUsart *uart = &(ser->USART);
	receiveKey = uart->DATA.reg;
	if(receiveKey != 13){
		receiveArray[receiveCount++] = receiveKey;
	}

}

void writeUart(char *a){
	Sercom *ser = SERCOM0;
	SercomUsart *uart = &(ser->USART);
	while(*a != '#'){
		while(!(uart->INTFLAG.bit.DRE)){}
		uart->DATA.reg = *a++;
		while((uart->INTFLAG.bit.TXC)==0){}	// waiting for transmit to complete
	}
}

void wait(volatile int d){
	int count = 0;
	while (count < d*1000){
		count++;
	}
}

