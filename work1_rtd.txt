


#include "sam.h"
#include "rtds.h"

/* Setup ports for RTDs */
void rtdPortSetup(void){
	
	Port *por = PORT;
	PortGroup *porA = &(por->Group[0]);
	PortGroup *porB = &(por->Group[1]);
	PortGroup *porC = &(por->Group[2]);
	PortGroup *porD = &(por->Group[3]);
	
	//ADCs
	porB->PMUX[2].bit.PMUXE = 1;	//PB04 ADC1 AIN[6] temp sensor
	porB->PINCFG[4].bit.PMUXEN = 1;

	//porC->PMUX[0].bit.PMUXE = 1;	//PC00 ADC1 AIN[10] extra
	//porC->PINCFG[0].bit.PMUXEN = 1;
	//
	//porC->PMUX[0].bit.PMUXO = 1;	//PC01 ADC1 AIN[11] extra
	//porC->PINCFG[1].bit.PMUXEN = 1;
	//
	//porC->PMUX[1].bit.PMUXE = 1;	//PC02 ADC1 AIN[4] RTD
	//porC->PINCFG[2].bit.PMUXEN = 1;
	//
	//porC->PMUX[1].bit.PMUXO = 1;	//PC03 ADC1 AIN[5] RTD
	//porC->PINCFG[3].bit.PMUXEN = 1;
	//
	//porA->PMUX[1].bit.PMUXE = 1;	//PA02 ADC0 AIN[0] RTD
	//porA->PINCFG[2].bit.PMUXEN = 1;
	//
	//porA->PMUX[1].bit.PMUXO = 1;	//PA03 ADC0 AIN[1] RTD
	//porA->PINCFG[3].bit.PMUXEN = 1;
	//
	//porB->PMUX[2].bit.PMUXO = 1;	//PB05 ADC1 AIN[7] RTD
	//porB->PINCFG[5].bit.PMUXEN = 1;
	//
	//porD->PMUX[0].bit.PMUXE = 1;	//PD00 ADC1 AIN[14] RTD
	//porD->PINCFG[0].bit.PMUXEN = 1;
	//
	//porD->PMUX[0].bit.PMUXO = 1;	//PD01 ADC1 AIN[15] RTD
	//porD->PINCFG[1].bit.PMUXEN = 1;
	//
	//porB->PMUX[4].bit.PMUXE = 1;	//PB06 ADC1 AIN[8] RTD
	//porB->PINCFG[8].bit.PMUXEN = 1;
	//
	//porB->PMUX[4].bit.PMUXO = 1;	//PB07 ADC1 AIN[9] RTD
	//porB->PINCFG[9].bit.PMUXEN = 1;
	//
}

/* Setup ADC1 */
void tempADC_Setup(void){
	ADC1->CTRLA.reg = 0<<1;	//disable so that we can reset
	while (ADC1->SYNCBUSY.reg){}	//wait for disable to complete
	ADC1->CTRLA.bit.PRESCALER = 0;	//2^n
	ADC1->CTRLA.bit.ONDEMAND = 1;
	
	ADC1->REFCTRL.reg = ADC_REFCTRL_REFSEL_INTVCC1;	//internal reference = VDDann
	while(ADC1->SYNCBUSY.bit.REFCTRL){}
	//ADC->CTRLB.reg = ADC_CTRLB_PRESCALER_DIV512 | ADC_CTRLB_RESSEL_8BIT | ADC_CTRLB_FREERUN | 0<<0 | ADC_CTRLB_CORREN;
	ADC1->CTRLB.reg = ADC_CTRLB_RESSEL_8BIT | 0<<1 | 0<<0;	// freerun mode off, right adjust
	while (ADC1->SYNCBUSY.bit.CTRLB){}	//wait for sync to complete
	ADC1->INPUTCTRL.reg = ADC_INPUTCTRL_MUXNEG_GND | ADC_INPUTCTRL_MUXPOS_AIN6;	//AIN6=PB04
	while (ADC1->SYNCBUSY.bit.INPUTCTRL){}	//wait for sync to complete
	ADC1->SWTRIG.bit.START = 1;	//start conversion
	while (ADC1->SYNCBUSY.bit.SWTRIG){}	//wait for sync to complete
	ADC1->INTENSET.reg = ADC_INTENSET_RESRDY;	//setup interrupt when reg is ready to be read
	ADC1->CTRLA.reg |= 1<<1;	//enable ADC
	while (ADC1->SYNCBUSY.reg){}	//wait for enable to complete
	NVIC->ISER[3] |= 1<<25;	//enable the NVIC handler
	//ADC0->OFFSETCORR.reg = 0b000000110100;	//shift down by 52, 2's comp
	//ADC0->GAINCORR.reg =   0b100010100000;	//when corren is enabled it enables gain comp too, fractional
}

//void tempTC_Setup(void){	//timer for reading the temp sensor
	//Tc *tc = TC4;
	//TcCount16 *tc4 = &tc->COUNT16;
	//tc4->CTRLA.reg = 0;	//disable the TC4
	//while(tc4->SYNCBUSY.reg){}	//wait for sync of disable
	//tc4->CTRLA.bit.PRESCALER = 4;	//2^n;
	//tc4->CTRLA.bit.MODE = 0;	//16 bit mode
	//tc4->CTRLBSET.bit.ONESHOT = 1;	//turn on one shot mode
	//while(tc4->SYNCBUSY.bit.CTRLB){}	//wait for sync to complete
	//tc4->INTENSET.bit.OVF = 1;	//enable the overflow interrupt
	//tc4->CTRLA.reg |= 1<<1;	//enable the TC4
	//while(tc4->SYNCBUSY.reg){}	//wait for sync of enable
	//NVIC->ISER[3] |= 1<<15;	//enable the NVIC handler for TC4
//}

/* Handler for board temperature sensor */
void ADC1_1_Handler(void){
	volatile int ADC_result = ADC1->RESULT.reg;	//read ADC conversion result
	volatile float result = (((float)ADC_result / 255) * 5);	//CHANGED float got changed from double
	result = (result - 1.375)/ .0225;
	convert((int)result);
}

//void TC4_Handler(void){
	//Tc *tc = TC4;
	//TcCount16 *tc4 = &tc->COUNT16;
	//tc4->INTFLAG.bit.OVF = 1;	//clear the int flag
	//ADC1->SWTRIG.reg = 1;//trigger ADC to start conversion
//}